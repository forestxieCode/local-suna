"""
Sandbox management module with support for multiple providers.

Supports:
- Docker (local/self-hosted) - NEW, China-friendly
- Daytona (legacy) - backward compatibility
- Automatic provider detection

Configuration via environment variables:
- SANDBOX_PROVIDER: docker | daytona
- CLOUD_PROVIDER: aliyun | tencent | local â†’ uses Docker
"""

import os
import asyncio
from typing import Optional, Dict, Any
from dotenv import load_dotenv

from core.utils.logger import logger
from core.utils.config import config

load_dotenv()

# Try to detect which sandbox system to use
SANDBOX_PROVIDER = os.getenv("SANDBOX_PROVIDER", "").lower()
CLOUD_PROVIDER = os.getenv("CLOUD_PROVIDER", "").lower()

# Determine if we should use the new adapter system or legacy Daytona
USE_ADAPTER_SYSTEM = (
    SANDBOX_PROVIDER == "docker" or
    CLOUD_PROVIDER in ["aliyun", "tencent", "local"] or
    (not config.DAYTONA_API_KEY and SANDBOX_PROVIDER != "daytona")
)

if USE_ADAPTER_SYSTEM:
    logger.info("ðŸ³ Using new sandbox adapter system (Docker-based)")
    from .compat import (
        get_or_start_sandbox,
        create_sandbox,
        CompatSandbox as AsyncSandbox,
        SandboxInfo,
        SandboxState,
        SessionExecuteRequest
    )
    
    # Export for compatibility
    __all__ = [
        'get_or_start_sandbox',
        'create_sandbox',
        'AsyncSandbox',
        'SandboxInfo',
        'SandboxState',
        'SessionExecuteRequest',
    ]

else:
    # Use legacy Daytona implementation
    logger.info("Using legacy Daytona sandbox system")
    
    try:
        from daytona_sdk import (
            AsyncDaytona,
            DaytonaConfig,
            CreateSandboxFromSnapshotParams,
            AsyncSandbox,
            SessionExecuteRequest,
            Resources,
            SandboxState
        )
        from core.utils.config import Configuration
        
        # Initialize Daytona client
        daytona_config = DaytonaConfig(
            api_key=config.DAYTONA_API_KEY,
            api_url=config.DAYTONA_SERVER_URL,
            target=config.DAYTONA_TARGET,
        )
        
        if daytona_config.api_key:
            logger.debug("Daytona sandbox configured successfully")
        else:
            logger.warning("No Daytona API key found in environment variables")
        
        if daytona_config.api_url:
            logger.debug(f"Daytona API URL set to: {daytona_config.api_url}")
        else:
            logger.warning("No Daytona API URL found in environment variables")
        
        if daytona_config.target:
            logger.debug(f"Daytona target set to: {daytona_config.target}")
        else:
            logger.warning("No Daytona target found in environment variables")
        
        daytona = AsyncDaytona(daytona_config)
        
        async def get_or_start_sandbox(sandbox_id: str) -> AsyncSandbox:
            """Retrieve a sandbox by ID, check its state, and start it if needed."""
            
            logger.info(f"Getting or starting sandbox with ID: {sandbox_id}")
        
            try:
                sandbox = await daytona.get(sandbox_id)
                
                # Check if sandbox needs to be started
                if sandbox.state in [SandboxState.ARCHIVED, SandboxState.STOPPED, SandboxState.ARCHIVING]:
                    logger.info(f"Sandbox is in {sandbox.state} state. Starting...")
                    try:
                        await daytona.start(sandbox)
                        
                        # Wait for sandbox to reach STARTED state
                        for _ in range(30):
                            await asyncio.sleep(1)
                            sandbox = await daytona.get(sandbox_id)
                            if sandbox.state == SandboxState.STARTED:
                                break
                        
                        # Start supervisord in a session when restarting
                        await start_supervisord_session(sandbox)
                    except Exception as e:
                        logger.error(f"Error starting sandbox: {e}")
                        raise e
                
                logger.info(f"Sandbox {sandbox_id} is ready")
                return sandbox
                
            except Exception as e:
                logger.error(f"Error retrieving or starting sandbox: {str(e)}")
                raise e
        
        async def start_supervisord_session(sandbox: AsyncSandbox):
            """Start supervisord in a session."""
            session_id = "supervisord-session"
            try:
                await sandbox.process.create_session(session_id)
                await sandbox.process.execute_session_command(session_id, SessionExecuteRequest(
                    command="exec /usr/bin/supervisord -n -c /etc/supervisor/conf.d/supervisord.conf",
                    var_async=True
                ))
                logger.info("Supervisord started successfully")
            except Exception as e:
                # Don't fail if supervisord already running
                logger.warning(f"Could not start supervisord: {str(e)}")
        
        async def create_sandbox(password: str, project_id: str = None) -> AsyncSandbox:
            """Create a new sandbox with all required services configured and running."""
            
            logger.info("Creating new Daytona sandbox environment")
            
            labels = None
            if project_id:
                labels = {'id': project_id}
                
            params = CreateSandboxFromSnapshotParams(
                snapshot=Configuration.SANDBOX_SNAPSHOT_NAME,
                public=True,
                labels=labels,
                env_vars={
                    "CHROME_PERSISTENT_SESSION": "true",
                    "RESOLUTION": "1048x768x24",
                    "RESOLUTION_WIDTH": "1048",
                    "RESOLUTION_HEIGHT": "768",
                    "VNC_PASSWORD": password,
                    "ANONYMIZED_TELEMETRY": "false",
                    "CHROME_PATH": "",
                    "CHROME_USER_DATA": "",
                    "CHROME_DEBUGGING_PORT": "9222",
                    "CHROME_DEBUGGING_HOST": "localhost",
                    "CHROME_CDP": ""
                },
                auto_stop_interval=15,
                auto_archive_interval=30,
            )
            
            # Create the sandbox
            
            # Wait for sandbox to be fully started
            logger.info("Waiting for sandbox to start...")
            for _ in range(60):
                await asyncio.sleep(2)
                sandbox = await daytona.get(sandbox.id)
                
                if sandbox.state == SandboxState.STARTED:
                    logger.info("âœ“ Sandbox is running")
                    break
            else:
                logger.warning("Sandbox may not be fully started after 120s")
            
            # Start supervisord
            await start_supervisord_session(sandbox)
            
            logger.info(f"Sandbox {sandbox.id} created successfully")
            return sandbox
            
        # Export for compatibility
        __all__ = [
            'get_or_start_sandbox',
            'create_sandbox',
            'start_supervisord_session',
            'AsyncSandbox',
            'SandboxState',
            'SessionExecuteRequest',
            'daytona',
        ]
        
    except ImportError as e:
        logger.error(f"Daytona SDK not available: {e}")
        logger.error("Please install daytona-sdk or set SANDBOX_PROVIDER=docker")
        
        # Fallback to adapter system
        logger.info("Falling back to adapter-based sandbox system")
        from .compat import (
            get_or_start_sandbox,
            create_sandbox,
            CompatSandbox as AsyncSandbox,
            SandboxInfo,
            SandboxState,
            SessionExecuteRequest
        )
        
        __all__ = [
            'get_or_start_sandbox',
            'create_sandbox',
            'AsyncSandbox',
            'SandboxInfo',
            'SandboxState',
            'SessionExecuteRequest',
        ]


    logger.info(f"Sandbox created with ID: {sandbox.id}")
    
    # Start supervisord in a session for new sandbox
    await start_supervisord_session(sandbox)
    
    logger.info(f"Sandbox environment successfully initialized")
    return sandbox

async def delete_sandbox(sandbox_id: str) -> bool:
    """Delete a sandbox by its ID."""
    logger.info(f"Deleting sandbox with ID: {sandbox_id}")

    try:
        # Get the sandbox
        sandbox = await daytona.get(sandbox_id)
        
        # Delete the sandbox
        await daytona.delete(sandbox)
        
        logger.info(f"Successfully deleted sandbox {sandbox_id}")
        return True
    except Exception as e:
        logger.error(f"Error deleting sandbox {sandbox_id}: {str(e)}")
        raise e
